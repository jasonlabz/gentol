// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.

package model

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/guregu/null"
	"github.com/satori/go.uuid"
)

var (
	_ = time.Second
	_ = sql.LevelDefault
	_ = null.Bool{}
	_ = uuid.UUID{}
)

const TableNameUser = "user"

type UserField string

// User struct is mapping to the user table
type User struct {
	UserID int32 `gorm:"primaryKey;autoIncrement;column:user_id;not null;type:int4;size:32;" json:"user_id"` // Comment: 用户ID

	Nickname string `gorm:"column:nickname;not null;type:varchar;size:255;" json:"nickname"` // Comment: 用户名

	Avatar string `gorm:"column:avatar;not null;type:varchar;size:255;" json:"avatar"` // Comment: 头像

	Password string `gorm:"column:password;not null;type:varchar;size:255;" json:"password"` // Comment: 用户密码 des/md5加密值

	Phone string `gorm:"column:phone;not null;type:varchar;size:255;default:'';" json:"phone"` // Comment: 手机号 aes加密

	Gender int32 `gorm:"column:gender;not null;type:int4;size:32;default:9;" json:"gender"` // Comment: 性别 0|男、1|女、9|未知

	Status int32 `gorm:"column:status;not null;type:int4;size:32;default:0;" json:"status"` // Comment: 状态 0|正常、1|注销、2|冻结

	RegisterIP string `gorm:"column:register_ip;not null;type:varchar;size:255;" json:"register_ip"` // Comment: no comment

	RegisterTime time.Time `gorm:"column:register_time;not null;type:timestamp;size:64;default:CURRENT_TIMESTAMP;" json:"register_time"` // Comment: no comment

	LastLoginIP string `gorm:"column:last_login_ip;not null;type:varchar;size:255;" json:"last_login_ip"` // Comment: no comment

	LastLoginTime time.Time `gorm:"column:last_login_time;not null;type:timestamp;size:64;default:CURRENT_TIMESTAMP;" json:"last_login_time"` // Comment: no comment

	CreateTime time.Time `gorm:"column:create_time;not null;type:timestamp;size:64;default:CURRENT_TIMESTAMP;" json:"create_time"` // Comment: no comment

	UpdateTime time.Time `gorm:"column:update_time;not null;type:timestamp;size:64;default:CURRENT_TIMESTAMP;" json:"update_time"` // Comment: no comment
}

type UserTableColumn struct {
	UserID        UserField
	Nickname      UserField
	Avatar        UserField
	Password      UserField
	Phone         UserField
	Gender        UserField
	Status        UserField
	RegisterIP    UserField
	RegisterTime  UserField
	LastLoginIP   UserField
	LastLoginTime UserField
	CreateTime    UserField
	UpdateTime    UserField
}

func (u *User) TableName() string {
	return "user"
}

func (u *User) GetColumnInfo() UserTableColumn {
	return UserTableColumn{
		UserID:        "user_id",
		Nickname:      "nickname",
		Avatar:        "avatar",
		Password:      "password",
		Phone:         "phone",
		Gender:        "gender",
		Status:        "status",
		RegisterIP:    "register_ip",
		RegisterTime:  "register_time",
		LastLoginIP:   "last_login_ip",
		LastLoginTime: "last_login_time",
		CreateTime:    "create_time",
		UpdateTime:    "update_time",
	}
}

type UserCondition struct {
	Condition
}

func (u *UserCondition) UserIDIsNull() *UserCondition {
	return u.AddStrCondition("user_id is null")
}

func (u *UserCondition) UserIDIsNotNull() *UserCondition {
	return u.AddStrCondition("user_id is not null")
}

func (u *UserCondition) UserIDEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("user_id = %v", value)
}

func (u *UserCondition) UserIDNotEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("user_id <> %v", value)
}

func (u *UserCondition) UserIDGreaterThan(value int32) *UserCondition {
	return u.AddStrCondition("user_id > %v", value)
}

func (u *UserCondition) UserIDGreaterThanOrEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("user_id >= %v", value)
}

func (u *UserCondition) UserIDLessThan(value int32) *UserCondition {
	return u.AddStrCondition("user_id < %v", value)
}

func (u *UserCondition) UserIDLessThanOrEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("user_id <= %v", value)
}

func (u *UserCondition) UserIDBetween(startValue, endValue int32) *UserCondition {
	return u.AddStrCondition("user_id between %v and %v", startValue, endValue)
}

func (u *UserCondition) UserIDNotBetween(startValue, endValue int32) *UserCondition {
	return u.AddStrCondition("user_id not between %v and %v", startValue, endValue)
}

func (u *UserCondition) UserIDIn(inValues []int32) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("user_id in ", inValues))
}

func (u *UserCondition) UserIDNotIn(inValues []int32) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("user_id not in ", inValues))
}

func (u *UserCondition) NicknameIsLike(value string) *UserCondition {
	return u.AddStrCondition("nickname like '%v'", value)
}

func (u *UserCondition) NicknameIsNull() *UserCondition {
	return u.AddStrCondition("nickname is null")
}

func (u *UserCondition) NicknameIsNotNull() *UserCondition {
	return u.AddStrCondition("nickname is not null")
}

func (u *UserCondition) NicknameEqualTo(value string) *UserCondition {
	return u.AddStrCondition("nickname = '%v'", value)
}

func (u *UserCondition) NicknameNotEqualTo(value string) *UserCondition {
	return u.AddStrCondition("nickname <> '%v'", value)
}

func (u *UserCondition) NicknameGreaterThan(value string) *UserCondition {
	return u.AddStrCondition("nickname > '%v'", value)
}

func (u *UserCondition) NicknameGreaterThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("nickname >= '%v'", value)
}

func (u *UserCondition) NicknameLessThan(value string) *UserCondition {
	return u.AddStrCondition("nickname < '%v'", value)
}

func (u *UserCondition) NicknameLessThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("nickname <= '%v'", value)
}

func (u *UserCondition) NicknameBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("nickname between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) NicknameNotBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("nickname not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) NicknameIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("nickname in ", inValues))
}

func (u *UserCondition) NicknameNotIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("nickname not in ", inValues))
}

func (u *UserCondition) AvatarIsLike(value string) *UserCondition {
	return u.AddStrCondition("avatar like '%v'", value)
}

func (u *UserCondition) AvatarIsNull() *UserCondition {
	return u.AddStrCondition("avatar is null")
}

func (u *UserCondition) AvatarIsNotNull() *UserCondition {
	return u.AddStrCondition("avatar is not null")
}

func (u *UserCondition) AvatarEqualTo(value string) *UserCondition {
	return u.AddStrCondition("avatar = '%v'", value)
}

func (u *UserCondition) AvatarNotEqualTo(value string) *UserCondition {
	return u.AddStrCondition("avatar <> '%v'", value)
}

func (u *UserCondition) AvatarGreaterThan(value string) *UserCondition {
	return u.AddStrCondition("avatar > '%v'", value)
}

func (u *UserCondition) AvatarGreaterThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("avatar >= '%v'", value)
}

func (u *UserCondition) AvatarLessThan(value string) *UserCondition {
	return u.AddStrCondition("avatar < '%v'", value)
}

func (u *UserCondition) AvatarLessThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("avatar <= '%v'", value)
}

func (u *UserCondition) AvatarBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("avatar between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) AvatarNotBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("avatar not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) AvatarIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("avatar in ", inValues))
}

func (u *UserCondition) AvatarNotIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("avatar not in ", inValues))
}

func (u *UserCondition) PasswordIsLike(value string) *UserCondition {
	return u.AddStrCondition("password like '%v'", value)
}

func (u *UserCondition) PasswordIsNull() *UserCondition {
	return u.AddStrCondition("password is null")
}

func (u *UserCondition) PasswordIsNotNull() *UserCondition {
	return u.AddStrCondition("password is not null")
}

func (u *UserCondition) PasswordEqualTo(value string) *UserCondition {
	return u.AddStrCondition("password = '%v'", value)
}

func (u *UserCondition) PasswordNotEqualTo(value string) *UserCondition {
	return u.AddStrCondition("password <> '%v'", value)
}

func (u *UserCondition) PasswordGreaterThan(value string) *UserCondition {
	return u.AddStrCondition("password > '%v'", value)
}

func (u *UserCondition) PasswordGreaterThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("password >= '%v'", value)
}

func (u *UserCondition) PasswordLessThan(value string) *UserCondition {
	return u.AddStrCondition("password < '%v'", value)
}

func (u *UserCondition) PasswordLessThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("password <= '%v'", value)
}

func (u *UserCondition) PasswordBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("password between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) PasswordNotBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("password not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) PasswordIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("password in ", inValues))
}

func (u *UserCondition) PasswordNotIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("password not in ", inValues))
}

func (u *UserCondition) PhoneIsLike(value string) *UserCondition {
	return u.AddStrCondition("phone like '%v'", value)
}

func (u *UserCondition) PhoneIsNull() *UserCondition {
	return u.AddStrCondition("phone is null")
}

func (u *UserCondition) PhoneIsNotNull() *UserCondition {
	return u.AddStrCondition("phone is not null")
}

func (u *UserCondition) PhoneEqualTo(value string) *UserCondition {
	return u.AddStrCondition("phone = '%v'", value)
}

func (u *UserCondition) PhoneNotEqualTo(value string) *UserCondition {
	return u.AddStrCondition("phone <> '%v'", value)
}

func (u *UserCondition) PhoneGreaterThan(value string) *UserCondition {
	return u.AddStrCondition("phone > '%v'", value)
}

func (u *UserCondition) PhoneGreaterThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("phone >= '%v'", value)
}

func (u *UserCondition) PhoneLessThan(value string) *UserCondition {
	return u.AddStrCondition("phone < '%v'", value)
}

func (u *UserCondition) PhoneLessThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("phone <= '%v'", value)
}

func (u *UserCondition) PhoneBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("phone between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) PhoneNotBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("phone not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) PhoneIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("phone in ", inValues))
}

func (u *UserCondition) PhoneNotIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("phone not in ", inValues))
}

func (u *UserCondition) GenderIsNull() *UserCondition {
	return u.AddStrCondition("gender is null")
}

func (u *UserCondition) GenderIsNotNull() *UserCondition {
	return u.AddStrCondition("gender is not null")
}

func (u *UserCondition) GenderEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("gender = %v", value)
}

func (u *UserCondition) GenderNotEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("gender <> %v", value)
}

func (u *UserCondition) GenderGreaterThan(value int32) *UserCondition {
	return u.AddStrCondition("gender > %v", value)
}

func (u *UserCondition) GenderGreaterThanOrEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("gender >= %v", value)
}

func (u *UserCondition) GenderLessThan(value int32) *UserCondition {
	return u.AddStrCondition("gender < %v", value)
}

func (u *UserCondition) GenderLessThanOrEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("gender <= %v", value)
}

func (u *UserCondition) GenderBetween(startValue, endValue int32) *UserCondition {
	return u.AddStrCondition("gender between %v and %v", startValue, endValue)
}

func (u *UserCondition) GenderNotBetween(startValue, endValue int32) *UserCondition {
	return u.AddStrCondition("gender not between %v and %v", startValue, endValue)
}

func (u *UserCondition) GenderIn(inValues []int32) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("gender in ", inValues))
}

func (u *UserCondition) GenderNotIn(inValues []int32) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("gender not in ", inValues))
}

func (u *UserCondition) StatusIsNull() *UserCondition {
	return u.AddStrCondition("status is null")
}

func (u *UserCondition) StatusIsNotNull() *UserCondition {
	return u.AddStrCondition("status is not null")
}

func (u *UserCondition) StatusEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("status = %v", value)
}

func (u *UserCondition) StatusNotEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("status <> %v", value)
}

func (u *UserCondition) StatusGreaterThan(value int32) *UserCondition {
	return u.AddStrCondition("status > %v", value)
}

func (u *UserCondition) StatusGreaterThanOrEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("status >= %v", value)
}

func (u *UserCondition) StatusLessThan(value int32) *UserCondition {
	return u.AddStrCondition("status < %v", value)
}

func (u *UserCondition) StatusLessThanOrEqualTo(value int32) *UserCondition {
	return u.AddStrCondition("status <= %v", value)
}

func (u *UserCondition) StatusBetween(startValue, endValue int32) *UserCondition {
	return u.AddStrCondition("status between %v and %v", startValue, endValue)
}

func (u *UserCondition) StatusNotBetween(startValue, endValue int32) *UserCondition {
	return u.AddStrCondition("status not between %v and %v", startValue, endValue)
}

func (u *UserCondition) StatusIn(inValues []int32) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("status in ", inValues))
}

func (u *UserCondition) StatusNotIn(inValues []int32) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("status not in ", inValues))
}

func (u *UserCondition) RegisterIPIsLike(value string) *UserCondition {
	return u.AddStrCondition("register_ip like '%v'", value)
}

func (u *UserCondition) RegisterIPIsNull() *UserCondition {
	return u.AddStrCondition("register_ip is null")
}

func (u *UserCondition) RegisterIPIsNotNull() *UserCondition {
	return u.AddStrCondition("register_ip is not null")
}

func (u *UserCondition) RegisterIPEqualTo(value string) *UserCondition {
	return u.AddStrCondition("register_ip = '%v'", value)
}

func (u *UserCondition) RegisterIPNotEqualTo(value string) *UserCondition {
	return u.AddStrCondition("register_ip <> '%v'", value)
}

func (u *UserCondition) RegisterIPGreaterThan(value string) *UserCondition {
	return u.AddStrCondition("register_ip > '%v'", value)
}

func (u *UserCondition) RegisterIPGreaterThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("register_ip >= '%v'", value)
}

func (u *UserCondition) RegisterIPLessThan(value string) *UserCondition {
	return u.AddStrCondition("register_ip < '%v'", value)
}

func (u *UserCondition) RegisterIPLessThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("register_ip <= '%v'", value)
}

func (u *UserCondition) RegisterIPBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("register_ip between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) RegisterIPNotBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("register_ip not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) RegisterIPIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("register_ip in ", inValues))
}

func (u *UserCondition) RegisterIPNotIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("register_ip not in ", inValues))
}

func (u *UserCondition) RegisterTimeIsNull() *UserCondition {
	return u.AddStrCondition("register_time is null")
}

func (u *UserCondition) RegisterTimeIsNotNull() *UserCondition {
	return u.AddStrCondition("register_time is not null")
}

func (u *UserCondition) RegisterTimeEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("register_time = '%v'", value)
}

func (u *UserCondition) RegisterTimeNotEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("register_time <> '%v'", value)
}

func (u *UserCondition) RegisterTimeGreaterThan(value time.Time) *UserCondition {
	return u.AddStrCondition("register_time > '%v'", value)
}

func (u *UserCondition) RegisterTimeGreaterThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("register_time >= '%v'", value)
}

func (u *UserCondition) RegisterTimeLessThan(value time.Time) *UserCondition {
	return u.AddStrCondition("register_time < '%v'", value)
}

func (u *UserCondition) RegisterTimeLessThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("register_time <= '%v'", value)
}

func (u *UserCondition) RegisterTimeBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("register_time between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) RegisterTimeNotBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("register_time not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) RegisterTimeIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("register_time in ", inValues))
}

func (u *UserCondition) RegisterTimeNotIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("register_time not in ", inValues))
}

func (u *UserCondition) LastLoginIPIsLike(value string) *UserCondition {
	return u.AddStrCondition("last_login_ip like '%v'", value)
}

func (u *UserCondition) LastLoginIPIsNull() *UserCondition {
	return u.AddStrCondition("last_login_ip is null")
}

func (u *UserCondition) LastLoginIPIsNotNull() *UserCondition {
	return u.AddStrCondition("last_login_ip is not null")
}

func (u *UserCondition) LastLoginIPEqualTo(value string) *UserCondition {
	return u.AddStrCondition("last_login_ip = '%v'", value)
}

func (u *UserCondition) LastLoginIPNotEqualTo(value string) *UserCondition {
	return u.AddStrCondition("last_login_ip <> '%v'", value)
}

func (u *UserCondition) LastLoginIPGreaterThan(value string) *UserCondition {
	return u.AddStrCondition("last_login_ip > '%v'", value)
}

func (u *UserCondition) LastLoginIPGreaterThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("last_login_ip >= '%v'", value)
}

func (u *UserCondition) LastLoginIPLessThan(value string) *UserCondition {
	return u.AddStrCondition("last_login_ip < '%v'", value)
}

func (u *UserCondition) LastLoginIPLessThanOrEqualTo(value string) *UserCondition {
	return u.AddStrCondition("last_login_ip <= '%v'", value)
}

func (u *UserCondition) LastLoginIPBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("last_login_ip between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) LastLoginIPNotBetween(startValue, endValue string) *UserCondition {
	return u.AddStrCondition("last_login_ip not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) LastLoginIPIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("last_login_ip in ", inValues))
}

func (u *UserCondition) LastLoginIPNotIn(inValues []string) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("last_login_ip not in ", inValues))
}

func (u *UserCondition) LastLoginTimeIsNull() *UserCondition {
	return u.AddStrCondition("last_login_time is null")
}

func (u *UserCondition) LastLoginTimeIsNotNull() *UserCondition {
	return u.AddStrCondition("last_login_time is not null")
}

func (u *UserCondition) LastLoginTimeEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time = '%v'", value)
}

func (u *UserCondition) LastLoginTimeNotEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time <> '%v'", value)
}

func (u *UserCondition) LastLoginTimeGreaterThan(value time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time > '%v'", value)
}

func (u *UserCondition) LastLoginTimeGreaterThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time >= '%v'", value)
}

func (u *UserCondition) LastLoginTimeLessThan(value time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time < '%v'", value)
}

func (u *UserCondition) LastLoginTimeLessThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time <= '%v'", value)
}

func (u *UserCondition) LastLoginTimeBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) LastLoginTimeNotBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("last_login_time not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) LastLoginTimeIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("last_login_time in ", inValues))
}

func (u *UserCondition) LastLoginTimeNotIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("last_login_time not in ", inValues))
}

func (u *UserCondition) CreateTimeIsNull() *UserCondition {
	return u.AddStrCondition("create_time is null")
}

func (u *UserCondition) CreateTimeIsNotNull() *UserCondition {
	return u.AddStrCondition("create_time is not null")
}

func (u *UserCondition) CreateTimeEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("create_time = '%v'", value)
}

func (u *UserCondition) CreateTimeNotEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("create_time <> '%v'", value)
}

func (u *UserCondition) CreateTimeGreaterThan(value time.Time) *UserCondition {
	return u.AddStrCondition("create_time > '%v'", value)
}

func (u *UserCondition) CreateTimeGreaterThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("create_time >= '%v'", value)
}

func (u *UserCondition) CreateTimeLessThan(value time.Time) *UserCondition {
	return u.AddStrCondition("create_time < '%v'", value)
}

func (u *UserCondition) CreateTimeLessThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("create_time <= '%v'", value)
}

func (u *UserCondition) CreateTimeBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("create_time between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) CreateTimeNotBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("create_time not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) CreateTimeIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("create_time in ", inValues))
}

func (u *UserCondition) CreateTimeNotIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("create_time not in ", inValues))
}

func (u *UserCondition) UpdateTimeIsNull() *UserCondition {
	return u.AddStrCondition("update_time is null")
}

func (u *UserCondition) UpdateTimeIsNotNull() *UserCondition {
	return u.AddStrCondition("update_time is not null")
}

func (u *UserCondition) UpdateTimeEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("update_time = '%v'", value)
}

func (u *UserCondition) UpdateTimeNotEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("update_time <> '%v'", value)
}

func (u *UserCondition) UpdateTimeGreaterThan(value time.Time) *UserCondition {
	return u.AddStrCondition("update_time > '%v'", value)
}

func (u *UserCondition) UpdateTimeGreaterThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("update_time >= '%v'", value)
}

func (u *UserCondition) UpdateTimeLessThan(value time.Time) *UserCondition {
	return u.AddStrCondition("update_time < '%v'", value)
}

func (u *UserCondition) UpdateTimeLessThanOrEqualTo(value time.Time) *UserCondition {
	return u.AddStrCondition("update_time <= '%v'", value)
}

func (u *UserCondition) UpdateTimeBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("update_time between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) UpdateTimeNotBetween(startValue, endValue time.Time) *UserCondition {
	return u.AddStrCondition("update_time not between '%v' and '%v'", startValue, endValue)
}

func (u *UserCondition) UpdateTimeIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("update_time in ", inValues))
}

func (u *UserCondition) UpdateTimeNotIn(inValues []time.Time) *UserCondition {
	if len(inValues) == 0 {
		return u
	}
	return u.AddStrCondition(TransInCondition("update_time not in ", inValues))
}

func (u *UserCondition) AddStrCondition(condition string, args ...any) *UserCondition {
	if len(args) > 0 {
		u.StringCondition = append(u.StringCondition, fmt.Sprintf(condition, args))
		return u
	}
	u.StringCondition = append(u.StringCondition, condition)
	return u
}

func (u *UserCondition) AddMapCondition(mapCondition map[string]any) *UserCondition {
	if len(u.MapCondition) == 0 {
		u.MapCondition = mapCondition
	} else {
		for key, val := range u.MapCondition {
			u.MapCondition[key] = val
		}
	}
	return u
}

func (u *UserCondition) AddOrderByClause(orderByClause ...string) *UserCondition {
	u.OrderByClause = append(u.OrderByClause, orderByClause...)
	return u
}

func (u *UserCondition) Build() *Condition {
	return &u.Condition
}
