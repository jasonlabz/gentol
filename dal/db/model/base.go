// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.

package model

import (
	"fmt"
	"math"
	"strings"
)

type ConditionBuilder interface {
	Build() *Condition
}

type Condition struct {
	MapCondition    map[string]any
	StringCondition []string
	OrderByClause   []string
}

type UpdateField map[string]any

// Pagination 分页结构体（该分页只适合数据量很少的情况）
type Pagination struct {
	Page      int64 `json:"page"`       // 当前页
	PageSize  int64 `json:"page_size"`  // 每页多少条记录
	PageCount int64 `json:"page_count"` // 一共多少页
	Total     int64 `json:"total"`      // 一共多少条记录
}

func (p *Pagination) CalculatePageCount() {
	if p.Page == 0 || p.PageSize == 0 {
		panic("error pagination param")
	}
	p.PageCount = int64(math.Ceil(float64(p.Total) / float64(p.PageSize)))
	return
}

func (p *Pagination) CalculateOffset() (offset int64) {
	if p.Page == 0 || p.PageSize == 0 {
		panic("error pagination param")
	}
	offset = (p.Page - 1) * p.PageSize
	return
}

func Values(value any) string {
	switch value.(type) {
	case int, int8, int16, int32, int64, bool, float32, float64:
		return fmt.Sprintf("%v", value)
	default:
		return fmt.Sprintf("'%v'", value)
	}
}

func TransInCondition[T any](prefix string, values []T) string {
	res := make([]string, 0)
	numbers := len(values) / 1000
	for i := 0; i < numbers; i++ {
		items := make([]string, 0)
		for j := i * 1000; j < (i+1)*1000; j++ {
			items = append(items, Values(values[j]))
		}
		res = append(res, fmt.Sprintf("%s (%s)", prefix, strings.Join(items, ",")))
	}
	items := make([]string, 0)
	for i := numbers * 1000; i < numbers*1000+len(values)%1000; i++ {
		items = append(items, Values(values[i]))
	}
	res = append(res, fmt.Sprintf("%s (%s)", prefix, strings.Join(items, ",")))
	return strings.Join(res, " or ")
}
