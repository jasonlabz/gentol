// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.

package dao

import (
	"context"
	"strings"

	"gorm.io/gorm/clause"

	"github.com/jasonlabz/gentol/dal/db/dao/interfaces"
	"github.com/jasonlabz/gentol/dal/db/model"
)

var _ interfaces.UserDao = &UserDaoImpl{}

type UserDaoImpl struct{}

func (u UserDaoImpl) SelectAll(ctx context.Context, selectFields ...model.UserField) (records []*model.User, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser)
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}
	err = tx.Find(&records).Error
	return
}

func (u UserDaoImpl) SelectOneByPrimaryKey(ctx context.Context, userID int32, selectFields ...model.UserField) (record *model.User, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser)
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}
	whereCondition := map[string]any{
		"user_id": userID,
	}
	err = tx.Where(whereCondition).First(&record).Error
	return
}

func (u UserDaoImpl) SelectRecordByCondition(ctx context.Context, condition *model.Condition, selectFields ...model.UserField) (records []*model.User, err error) {
	if condition == nil {
		return u.SelectAll(ctx, selectFields...)
	}
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser)
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}
	for _, strCondition := range condition.StringCondition {
		tx = tx.Where(strCondition)
	}
	if len(condition.MapCondition) > 0 {
		tx = tx.Where(condition.MapCondition)
	}
	for _, order := range condition.OrderByClause {
		tx = tx.Order(order)
	}
	err = tx.Find(&records).Error
	return
}

func (u UserDaoImpl) SelectPageRecordByCondition(ctx context.Context, condition *model.Condition, pageParam *model.Pagination,
	selectFields ...model.UserField) (records []*model.User, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser)
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}

	if condition != nil {
		for _, strCondition := range condition.StringCondition {
			tx = tx.Where(strCondition)
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
		for _, order := range condition.OrderByClause {
			tx = tx.Order(order)
		}
	}
	var count int64
	if pageParam != nil {
		tx = tx.Count(&count).Offset(int(pageParam.CalculateOffset())).Limit(int(pageParam.PageSize))
	}
	err = tx.Find(&records).Error
	if pageParam != nil {
		pageParam.Total = count
		pageParam.CalculatePageCount()
	}
	return
}

func (u UserDaoImpl) CountByCondition(ctx context.Context, condition *model.Condition) (count int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser)
	if condition != nil {
		for _, strCondition := range condition.StringCondition {
			tx = tx.Where(strCondition)
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
	}
	err = tx.Count(&count).Error
	return
}

func (u UserDaoImpl) DeleteByCondition(ctx context.Context, condition *model.Condition) (affect int64, err error) {
	tx := DB().WithContext(ctx)
	if condition != nil {
		for _, strCondition := range condition.StringCondition {
			tx = tx.Where(strCondition)
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
	}
	tx = tx.Delete(&model.User{})
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) DeleteByPrimaryKey(ctx context.Context, userID int32) (affect int64, err error) {
	whereCondition := map[string]any{
		"user_id": userID,
	}
	tx := DB().WithContext(ctx).Where(whereCondition).Delete(&model.User{})
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) UpdateRecord(ctx context.Context, record *model.User) (affect int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser).
		Save(record)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) UpdateRecords(ctx context.Context, records []*model.User) (affect int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser).
		Save(records)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) UpdateByCondition(ctx context.Context, condition *model.Condition, updateField *model.UpdateField) (affect int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser)
	if condition != nil {
		for _, strCondition := range condition.StringCondition {
			tx = tx.Where(strCondition)
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
	}
	tx = tx.Updates(updateField)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) UpdateByPrimaryKey(ctx context.Context, userID int32, updateField *model.UpdateField) (affect int64, err error) {
	whereCondition := map[string]any{
		"user_id": userID,
	}
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser).
		Where(whereCondition)
	tx = tx.Updates(updateField)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) Insert(ctx context.Context, record *model.User) (affect int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser).
		Create(&record)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) BatchInsert(ctx context.Context, records []*model.User) (affect int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser).
		Create(&records)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) InsertOrUpdateOnDuplicateKey(ctx context.Context, record *model.User) (affect int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser).
		Clauses(clause.OnConflict{
			UpdateAll: true,
		}).Create(&record)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u UserDaoImpl) BatchInsertOrUpdateOnDuplicateKey(ctx context.Context, records []*model.User) (affect int64, err error) {
	tx := DB().WithContext(ctx).
		Table(model.TableNameUser).
		Clauses(clause.OnConflict{
			UpdateAll: true,
		}).Create(&records)
	affect = tx.RowsAffected
	err = tx.Error
	return
}
